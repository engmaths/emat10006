<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/emat10006/libs/highlight/github.min.css"> <link rel=stylesheet  href="/emat10006/css/franklin.css"> <link rel=stylesheet  href="/emat10006/css/basic.css"> <link rel=icon  href="/emat10006/assets/favicon.png"> <title> &mdash; Further Computer Programming</title> <header> <div class=blog-name ><a href="">EMAT10006: Further Computer Programming</a></div> <nav> <ul> <li><a href="/emat10006/">Overview</a> <li><a href="/emat10006/materials/">Materials</a> <li><a href="/emat10006/cheatsheet/">Cheatsheet</a> <li><a href="/emat10006/assignment/">Assignment</a> </ul> <img src="/emat10006/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content ><p>EMAT10006: Further Computer Programming<br /> Week 19 – Git Branches and Python Classes<br /> <hr /></p> <p><strong>Please note, even if you have an extension for Assignment 2, you should not work on it in this lab. Not completing this worksheet will put everyone else in your group at a significant disadvantage going forward into Assignment 3.</strong></p> <p>For this week&#39;s worksheet, and the final assignment, you will need to work in groups of four. All the people in your group <strong>must</strong> be in your TA group. Most TA groups have 8 students, so this should work in most cases. Where there aren&#39;t 8, make sure you check your group sizes with your TA / Simon or Chanelle before getting started. There should be <strong>no groups of five or two</strong> and wherever possible, groups should be of four&#33;<br />Your TA has a sheet which needs to be filled out with who is in each group.<br />Today we will be fixing and extending a library database program in your groups. Along the way we will:</p> <ol> <li><p>learn to use <em>branches</em> in Git to help workflow in larger groups,</p> <li><p>practice using classes and inheritance in Python.</p> </ol> <h1>Using branches to work simultaneously</h1> <p>Many people consider branching to be Git&#39;s &#39;killer feature&#39;, and the main reason why its use is so commonplace in code development. Branching allows you to diverge from the main development line of some code, and make changes without messing up the main line. Later, when you and your collaborators are happy with the changes on the branch, it can be merged back to the main line of development. Meanwhile other branches may have been made by others, and by using <em>pull requests</em> &#40;a feature of GitHub, not Git&#41; we can make informed decisions on which branches should be merged with the master, and when.<br />Branches allow us to maintain a robust &#39;workflow&#39;, where all changes to code are made on copies of the master; this means the master only ever contains reviewed, finished and bug-free code. Common reasons for branching might be to fix bugs, or add new features, which is exactly what we are going to do here.<br />From now on, we are never going to commit changes directly to our master, and we are also never going to push directly to the remote repo&#39;s master&#33; Instead we are going to make branches, where we can write experimental code without having to worry about messing up the whole project. We will then use pull-requests to merge our changes once they are complete.<br />As usual, carefully follow through the following steps, making sure you understand each bullet point beofre moving on to the next. If you are unsure at any point, discuss it in your group, and ask your TA.</p> <ul> <li><p>First off, accept this &#39;assignment&#39; on GitHub classroom. <strong>Don&#39;t worry this isn&#39;t an actual, marked assessment</strong> – it&#39;s just an easy way to get you the template code. Inside the repo is a part-finished and slightly buggy library databasing program, complete with some data. Read the program&#39;s readme to understand how it works. The program makes extensive use of classes and class hierarchy. If you need a reminder of scope, inheritance and the object-orientated side of Python, then have a look at <a href="https://docs.python.org/3/tutorial/classes.html">&#91;this tutorial&#93;&#123;.underline&#125;</a>.</p> <li><p>Sort out your GitHub Classroom team with all three / four of you in. For now, split into two pairs, one pair is going to fix some existing bugs in the code and one pair is going to add a new feature. Each pair use one just one computer each. Clone the repo so there are now three repos in total: one on the bug-fixing pair&#39;s machine, one on the feature pair&#39;s machine, and the remote one on GitHub.</p> <li><p>Your local repos already in fact have a branch&#33; Typing <code>git status</code>&#123;.text&#125;, you&#39;ll notice it tells you you are on a branch called master. Git makes this branch when you clone the repo, and gives it the default name &#39;master&#39;. Note that each pair&#39;s master branch is <em>their own</em> master branch, it is not shared, and the remote repo has it&#39;s own too. GitHub denotes these in a similar way to paths on your computer, e.g. <code>origin/master</code>&#123;.text&#125; refers to the remote repo&#39;s master &#40;since by default GitHub calls the remote repo &#39;origin&#39;&#41;.</p> <li><p>Branches are basically just simple &#39;pointers&#39;, pointing to a particular commit in the commit history. If you were to start making commits now, the commit that master is pointing to would automatically move forward to each new commit. This is how we&#39;ve been working so far.</p> <li><p>Each pair make a new branch. Do this by using the command <code>git branch branch_name</code>&#123;.text&#125;, where one pair replaces <code>branch_name</code>&#123;.text&#125; with <code>bug-fix</code>&#123;.text&#125; and the other pair replaces it with <code>new-feature</code>&#123;.text&#125;. These are the names of your branches. This creates a new branch, pointing at the current commit. So currently, master and the new branch are both pointing to the same commit, the initial commit. Below I&#39;ll refer to &#39;your new branch&#39;, and I mean either bug-fix or new-feature, whichever you are working on.</p> <li><p>Git keeps track of which branch you are on using a special unique pointer called HEAD. HEAD is currently pointing at master, and master is pointing at the initial commit.</p> <li><p>Use the command <code>git branch -a</code>&#123;.text&#125; to show all current branches. You can see local branches and remote branches. There are also clear indications where the HEAD is currently pointing &#40;the asterisk, and sometimes colours depending on your terminal&#41;.</p> <li><p>We want to work on our new branches, not on master, so we want HEAD to point to your new branch. The command <code>git checkout your_new_branch</code>&#123;.text&#125; moves the head to point at your new branch. Now, whenever you commit any changes, your new branch&#39;s pointer automatically moves to them, but the master branch stays at the initial commit. So if you were to checkout master again, the actual files in your local repo would be changed to reflect the commit that master was left on. More on this later, for now, a quick programming task for both pairs.</p> </ul> <p><strong>Exercise</strong><br />While on your new branches, either pair should do the following exercises, making a couple of commits as normal while you do the task. <strong>But do not push anything yet&#33;</strong></p> <ul> <li><p>Bug-fix pair: The following four bugs have been identified:</p> <ul> <li><p>Adding lists of new items makes the old items disappear.</p> <li><p>The system does not raise any errors when an item is returned by a user who is not listed as the borrower.</p> <li><p>The searching ability is not very good. For example, if I search for &quot;title&#61;jurassic&quot; it should return only the DVD &quot;Jurassic World&quot;.</p> <li><p>When an item has been reserved by a user and the user then requests the item, the system says the item is unavailable because it has already been reserved.</p> </ul> <li><p>Feature pair: The library would like to separate fiction and non-fiction books. Fiction books should have a genre attribute and non-fiction books should have a subject attribute. Please also change demo.py to reflect these changes.</p> </ul> <p>Whoever finishes first should carry on with the walkthrough without waiting for the other pair. I&#39;ll refer to those who finish first as Pair 1, and the others as Pair 2.<br /></p> <ul> <li><p>So now, we&#39;re at a point where the master branch of all three repos is still pointing at the initial commit, and either pair&#39;s new branch is pointing to their most recent commit. We now want to merge all of these changes, and eventually have one unified master branch on the GitHub remote repo.</p> <li><p>Firstly try switching back to your master branch, using <code>git checkout master</code>&#123;.text&#125;. Reload the files you changed... all your changes have vanished&#33; This is because you are now looking at the code as it was at the initial commit, because that is where master is pointing, and HEAD is now pointing at master. You haven&#39;t lost the changes though, as Git still has those commits. Git has just reverted your local repo to look like the commit that master is pointing at. What does <code>git log</code>&#123;.text&#125; show?</p> <li><p>Pair 1: You now think the code on your branch is good to go. Push your branch up to the remote repo by entering the command <code>git push --set-upstream origin your_new_branch</code>&#123;.text&#125;. Go onto your remote reop&#39;s webpage on GitHub, and click branches. You&#39;ll see your branch there now, which has all your commits since opening the branch.</p> <li><p>Pair 1: Click &#39;New pull request&#39;, enter an informative message if you like, then click &#39;Create new pull request&#39;. Get Pair 2 to stop what they&#39;re doing, commit any changes to their branch and do the next few bullet points.</p> <li><p>Pair 2: Pair 1 have created a pull request, which means they want to merge their branch on the remote repo with the master on the remote repo. You should first review their code, to make sure it works and doesn&#39;t have any bugs&#33; This is good programming practice. To do this you will need your local repo to update itself with their new branch. Run the command <code>git fetch</code>&#123;.text&#125;, which fetches all the changes from your upstream, which here is origin &#40;the remote repo on GitHub&#41;. Notice from the output that is has fetched their new branch.</p> <li><p>Pair 2: Run <code>git checkout their_new_branch</code>&#123;.text&#125;, and your repo will now look like Pair 1&#39;s most recent commit, that they think is finished. You can now look at their changes, test out the new bug-fix / feature, etc.</p> <li><p>Both pairs should now discuss the changes, and once everyone is happy, Pair 2 should go to the &#39;Pull requests&#39; tab on the repo&#39;s webpage, and confirm the pull request, which will merge the branch to master on the remote repo. Note: since you are sat next to each other you can discuss in person but, when you are not, you can use GitHub&#39;s comments to discuss the changes.</p> <li><p>Pair 1: pull down the changes from origin to your master.</p> <li><p>Pair 2: checkout your master branch, and pull down the changes from origin. Now your master has all of Pair 1&#39;s changes, and master is pointing to the merge commit.</p> <li><p>Pair 2: now you should merge your master branch into your new branch. This will bring Pair 1&#39;s changes and attempt to merge them with your changes. First checkout your new branch, then run <code>git merge master</code>&#123;.text&#125;. This will attempt to merge the changes on master into your new branch. This may happen automatically or there may be merge conflicts which will need resolving. Notice how merges have a <em>direction</em>. What we have just done is different to merging your new branch into master. Check <code>git log</code>&#123;.text&#125; to see the merge commit.</p> <li><p>Pair 2: Now finish your changes on your branch. Commit them, push the branch up to the remote, create a merge request, and both pairs follow through the above instructions the other way around. By the end all three master branches should be pointing at the same commit.</p> </ul> <p><strong>N.B.</strong> You may have noticed how <em>quick</em> branching is. It&#39;s more noticeable on larger projects, but branching in using Git is very efficient and lightweight. Files are never &#39;copy and pasted&#39; or duplicated anywhere. Branches are just files containing 40 bytes of data, identifying which commit that branch is pointing to. Branching using other version control systems &#40;VCSs&#41; often involves copying all or most of the project to a new directory, meaning there&#39;s considerably more &#39;cost&#39; involved with making a branch, or moving between branches.<br /> Important lessons about workflow ––––––––––––––––</p> <p>A <em>workflow</em> is an organised and repeatable pattern of working, which encourages consistency, robustness and is shared by collaborators. The pattern of work we have just done follows one particular workflow, which is summarised in the figure below. The boxes are all branches, and you can think of the arrows as the &#39;flow of commits&#39; throughout the project, with the associated Git / GitHub command in blue. Refer back to this whenever you need to remind yourself of where you should be commiting, and how.<br />Assignment 3 will mark you based on how consistently your group uses good workflow&#33; We will be able to see how you have used branches by looking through your merge commits.</p> <p><img src=workflow.pdf  alt="A schematic of the workflow we have used to update the library program with a new feature and some bug-fixes. Each boxed-off grey region is a different repo &#40;2 local and one remote&#41;, each square inside is a branch on that repo, and arrows represent how commits move around." />&#123;width&#61;&quot;90&#37;&quot;&#125;</p> <p>Some important observations about this workflow:</p> <ol> <li><p>We never commited any changed directly to our master branch&#33; This is good practice, as it means master only ever has code on it which have been finished and reviewed. The only way your local master should change is by pulling from the remote&#39;s master. In the figure, the only place commits are actually made &#40;besides merge commits&#41; is on your new branches.</p> <li><p>From now on <strong>all</strong> changes should you make should be committed to a local branch and never to master. This branch should be pushed to remote. From here pull requests should be made to the master once the feature / bug has been completed.</p> <li><p>Again, notice how nothing is pushed directly to master on the remote either. This ensures all code which ends up on the master only gets there via a pull request which is reviewed by other team members.</p> </ol> <h2>New commands</h2> <p>We&#39;ve seen several new Git commands today, which are summarised here:</p> <ol> <li><p><code>git branch branch_name</code>&#123;.text&#125;, creates a new branch called <code>branch_name</code>&#123;.text&#125;. HEAD remains where it was.</p> <li><p><code>git branch -a</code>&#123;.text&#125; lists all existing branches, including local and remote branches. Also indicates which one HEAD is pointing at.</p> <li><p><code>git checkout this_branch</code>&#123;.text&#125; moves HEAD to point at <code>this_branch</code>&#123;.text&#125;. This is how to move between branches. It&#39;s important to remember if you move HEAD to a branch which is pointing at a different commit to where you were previously, your files will be updated to reflect the commit that branch is pointing to.</p> <li><p><code>git fetch</code>&#123;.text&#125; updates our local repo by fetching all of the latest branches from the remote repo. We can now checkout these branches to view branches which have been pushed up. Note no branches are merged, this does nothing to your local branches&#33;</p> <li><p><code>git merge other_branch</code>&#123;.text&#125; attempts to merge <code>other_branch</code>&#123;.text&#125; into the branch HEAD is currently pointing to. The merge may then go ahead automatically, depending on if there are any conflicts.</p> <li><p>It&#39;s perhaps useful to point out that <code>git pull</code>&#123;.text&#125; actually just runs <code>git fetch</code>&#123;.text&#125;, followed by <code>git merge</code>&#123;.text&#125;. So the way you will have used it until now, <code>git pull</code>&#123;.text&#125; just pulls commits from <code>origin/master</code>&#123;.text&#125; and immediately tries to merge them with your local master.</p> </ol> <h1>Further extensions to the library program</h1> <p>Further extensions you could make to the library system include:</p> <ul> <li><p>At the moment the system has no way of storing data. Every time demo.py is run, a new <code>Library</code>&#123;.text&#125; object is created. Can you add a way of storing the information so it can be reloaded?</p> <li><p>Can you create a <code>User</code>&#123;.text&#125; class which would store information about the user? This would include a unique id number and all the items they have borrowed and reserved.</p> <li><p>The library system is unable to fine users for returning books late. Can you add a way of working out how long items have been borrowed for, and if user needs to pay a fine.</p> </ul> <p>Note that the above are just examples of some ways that the library system could be extended, you might have other ideas of a interesting and useful features. Your group should extend the library program by adding two new features. Each pair should work on a separate feature and aim to use the workflow detailed above.</p> <div class=page-foot > <div class=copyright > &copy; Oscar Benjamin. Last modified: February 08, 2022. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div>